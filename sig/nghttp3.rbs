module Nghttp3
  VERSION: String

  # nghttp3 library compile-time constants
  NGHTTP3_VERSION: String
  NGHTTP3_VERSION_NUM: Integer
  NGHTTP3_VERSION_AGE: Integer

  # nghttp3 error code constants
  NGHTTP3_ERR_INVALID_ARGUMENT: Integer
  NGHTTP3_ERR_INVALID_STATE: Integer
  NGHTTP3_ERR_WOULDBLOCK: Integer
  NGHTTP3_ERR_STREAM_IN_USE: Integer
  NGHTTP3_ERR_MALFORMED_HTTP_HEADER: Integer
  NGHTTP3_ERR_MALFORMED_HTTP_MESSAGING: Integer
  NGHTTP3_ERR_QPACK_FATAL: Integer
  NGHTTP3_ERR_QPACK_HEADER_TOO_LARGE: Integer
  NGHTTP3_ERR_STREAM_NOT_FOUND: Integer
  NGHTTP3_ERR_CONN_CLOSING: Integer
  NGHTTP3_ERR_STREAM_DATA_OVERFLOW: Integer
  NGHTTP3_ERR_FATAL: Integer
  NGHTTP3_ERR_NOMEM: Integer
  NGHTTP3_ERR_CALLBACK_FAILURE: Integer

  # NV flag constants
  NV_FLAG_NONE: Integer
  NV_FLAG_NEVER_INDEX: Integer
  NV_FLAG_NO_COPY_NAME: Integer
  NV_FLAG_NO_COPY_VALUE: Integer
  NV_FLAG_TRY_INDEX: Integer

  # Returns runtime version info, or nil if least_version requirement not met
  def self.library_version: (?Integer least_version) -> Info?

  # Returns true if the given error code represents a fatal error
  def self.err_is_fatal?: (Integer error_code) -> bool

  # Returns a textual representation of the given error code
  def self.strerror: (Integer error_code) -> String

  class Info
    def age: () -> Integer
    def version_num: () -> Integer
    def version_str: () -> String
  end

  class Error < StandardError
  end

  class InvalidArgumentError < Error
  end

  class InvalidStateError < Error
  end

  class WouldBlockError < Error
  end

  class StreamInUseError < Error
  end

  class MalformedHTTPHeaderError < Error
  end

  class MalformedHTTPMessagingError < Error
  end

  class QPACKFatalError < Error
  end

  class QPACKHeaderTooLargeError < Error
  end

  class StreamNotFoundError < Error
  end

  class ConnClosingError < Error
  end

  class StreamDataOverflowError < Error
  end

  class FatalError < Error
  end

  class NoMemError < Error
  end

  class CallbackFailureError < Error
  end

  class Settings
    def self.default: () -> Settings

    def initialize: () -> void

    def max_field_section_size: () -> Integer
    def max_field_section_size=: (Integer value) -> Integer

    def qpack_max_dtable_capacity: () -> Integer
    def qpack_max_dtable_capacity=: (Integer value) -> Integer

    def qpack_encoder_max_dtable_capacity: () -> Integer
    def qpack_encoder_max_dtable_capacity=: (Integer value) -> Integer

    def qpack_blocked_streams: () -> Integer
    def qpack_blocked_streams=: (Integer value) -> Integer

    def enable_connect_protocol: () -> bool
    def enable_connect_protocol=: (boolish value) -> boolish

    def h3_datagram: () -> bool
    def h3_datagram=: (boolish value) -> boolish
  end

  class NV
    def initialize: (String name, String value, ?flags: Integer) -> void

    def name: () -> String
    def value: () -> String
    def flags: () -> Integer
  end

  class Callbacks
    def initialize: () -> void

    # Stream data callbacks
    def on_acked_stream_data: () { (Integer stream_id, Integer datalen) -> void } -> self
    def on_stream_close: () { (Integer stream_id, Integer app_error_code) -> void } -> self
    def on_recv_data: () { (Integer stream_id, String data) -> void } -> self
    def on_deferred_consume: () { (Integer stream_id, Integer consumed) -> void } -> self

    # Header callbacks
    def on_begin_headers: () { (Integer stream_id) -> void } -> self
    def on_recv_header: () { (Integer stream_id, String name, String value, Integer flags) -> void } -> self
    def on_end_headers: () { (Integer stream_id, bool fin) -> void } -> self

    # Trailer callbacks
    def on_begin_trailers: () { (Integer stream_id) -> void } -> self
    def on_recv_trailer: () { (Integer stream_id, String name, String value, Integer flags) -> void } -> self
    def on_end_trailers: () { (Integer stream_id, bool fin) -> void } -> self

    # Stream control callbacks
    def on_stop_sending: () { (Integer stream_id, Integer app_error_code) -> void } -> self
    def on_end_stream: () { (Integer stream_id) -> void } -> self
    def on_reset_stream: () { (Integer stream_id, Integer app_error_code) -> void } -> self

    # Connection callbacks
    def on_shutdown: () { (Integer id) -> void } -> self
    def on_recv_settings: () { (Hash[Symbol, untyped] settings) -> void } -> self
  end

  class Connection
    # Creates a new client connection
    def self.client_new: (?Settings? settings, ?Callbacks? callbacks) -> Connection

    # Creates a new server connection
    def self.server_new: (?Settings? settings, ?Callbacks? callbacks) -> Connection

    # Binds the control stream
    def bind_control_stream: (Integer stream_id) -> self

    # Binds QPACK encoder and decoder streams
    def bind_qpack_streams: (Integer encoder_stream_id, Integer decoder_stream_id) -> self

    # Closes the connection
    def close: () -> nil

    # Returns true if the connection is closed
    def closed?: () -> bool

    # Returns true if this is a server connection
    def server?: () -> bool

    # Returns true if this is a client connection
    def client?: () -> bool
  end
end
